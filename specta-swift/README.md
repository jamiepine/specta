# Specta Swift

[![Crates.io](https://img.shields.io/crates/v/specta-swift.svg)](https://crates.io/crates/specta-swift)
[![Documentation](https://docs.rs/specta-swift/badge.svg)](https://docs.rs/specta-swift)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

A Rust crate for exporting Rust types to Swift, built on top of [Specta](https://github.com/oscartbeaumont/specta). Generate idiomatic Swift code from your Rust type definitions with support for complex unions, generics, and nested structures.

## Features

- üöÄ **Zero Runtime Cost** - Compile-time type generation
- üéØ **Idiomatic Swift** - Generates clean, Swift-idiomatic code
- üîÑ **Complex Unions** - Full support for Rust enums with all variant types
- üß¨ **Generics** - Single and multiple generic type parameters
- üîó **Recursive Types** - Self-referencing and circular type definitions
- ‚öôÔ∏è **Configurable** - Customizable naming conventions and optional styles
- üì¶ **Type Safety** - Leverages Specta's robust type introspection
- üß™ **Well Tested** - Comprehensive test suite with snapshot testing

## Quick Start

Add `specta-swift` to your `Cargo.toml`:

```toml
[dependencies]
specta = { version = "2.0", features = ["derive"] }
specta-swift = "0.1"
```

Define your Rust types:

```rust
use specta::{Type, TypeCollection};
use specta_swift::Swift;

#[derive(Type)]
struct User {
    id: u32,
    name: String,
    email: Option<String>,
    role: UserRole,
}

#[derive(Type)]
enum UserRole {
    Guest,
    User { permissions: Vec<String> },
    Admin { level: u8, department: String },
}

#[derive(Type)]
enum ApiResult<T> {
    Success { data: T, status: u16 },
    Error { message: String, code: u32 },
    Loading { progress: f32 },
}
```

Generate Swift code:

```rust
fn main() {
    let types = TypeCollection::default()
        .register::<User>()
        .register::<UserRole>()
        .register::<ApiResult<String>>();

    let swift = Swift::default();
    swift.export_to("./Types.swift", &types).unwrap();
}
```

This generates:

```swift
// This file has been generated by Specta. DO NOT EDIT.
import Foundation

enum ApiResult<T>: Codable {
    case success(data: T, status: UInt16)
    case error(message: String, code: UInt32)
    case loading(progress: Float)
}

struct User: Codable {
    let id: UInt32
    let name: String
    let email: String?
    let role: UserRole
}

enum UserRole: Codable {
    case guest
    case user(permissions: [String])
    case admin(level: UInt8, department: String)
}
```

## Advanced Features

### Complex Union Types

Specta Swift supports all Rust enum variant types:

```rust
#[derive(Type)]
enum ComplexUnion {
    // Unit variant
    None,

    // Tuple variant
    Tuple(String, u32, bool),

    // Named fields variant
    NamedFields {
        id: u32,
        name: String,
        active: bool,
    },

    // Nested struct variant
    UserStruct(User),

    // Nested enum variant
    UserType(UserType),

    // Complex nested structure
    Complex {
        user: User,
        metadata: Vec<String>,
        settings: Option<Admin>,
    },
}
```

Generates:

```swift
enum ComplexUnion: Codable {
    case none
    case tuple(String, UInt32, Bool)
    case namedfields(id: UInt32, name: String, active: Bool)
    case userstruct(User)
    case usertype(UserType)
    case complex(user: User, metadata: [String], settings: Admin?)
}
```

### Generic Types

Full support for generic types with multiple parameters:

```rust
#[derive(Type)]
enum DatabaseResult<T, E> {
    Ok { data: T, affected_rows: u64 },
    Err { error: E, query: String },
    ConnectionError { host: String, port: u16 },
}
```

### Recursive Types

Self-referencing types are fully supported:

```rust
#[derive(Type)]
enum Shape {
    None,
    Point(f64, f64),
    Circle { center: Point, radius: f64 },
    Complex { shapes: Vec<Shape>, metadata: Option<String> },
}
```

## Configuration

### Naming Conventions

```rust
use specta_swift::{Swift, NamingConvention};

// PascalCase (default)
let swift = Swift::default();

// camelCase
let swift = Swift::new().naming(NamingConvention::CamelCase);

// snake_case
let swift = Swift::new().naming(NamingConvention::SnakeCase);
```

### Optional Styles

```rust
use specta_swift::{Swift, OptionalStyle};

// T? syntax (default)
let swift = Swift::default();

// Optional<T> syntax
let swift = Swift::new().optionals(OptionalStyle::Optional);
```

### Custom Headers

```rust
let swift = Swift::new()
    .header("// Generated by MyApp - Custom Header")
    .naming(NamingConvention::SnakeCase);
```

## Type Mapping

| Rust Type                 | Swift Type                            |
| ------------------------- | ------------------------------------- |
| `i8`, `i16`, `i32`, `i64` | `Int8`, `Int16`, `Int32`, `Int64`     |
| `u8`, `u16`, `u32`, `u64` | `UInt8`, `UInt16`, `UInt32`, `UInt64` |
| `f32`, `f64`              | `Float`, `Double`                     |
| `bool`                    | `Bool`                                |
| `String`                  | `String`                              |
| `Option<T>`               | `T?` or `Optional<T>`                 |
| `Vec<T>`                  | `[T]`                                 |
| `HashMap<K, V>`           | `[K: V]`                              |
| `(T, U)`                  | `(T, U)`                              |
| `struct`                  | `struct`                              |
| `enum`                    | `enum`                                |

## Examples

Check out the `examples/` directory for more comprehensive examples:

- `simple_usage.rs` - Basic usage with different configurations
- `complex_types.rs` - Advanced features showcase

## Testing

Run the test suite:

```bash
cargo test
```

The test suite includes:

- Basic type generation tests
- Comprehensive union type tests
- Advanced recursive type tests
- Snapshot testing for generated code

## Contributing

Contributions are welcome! Please see the main [Specta repository](https://github.com/oscartbeaumont/specta) for contribution guidelines.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Related Projects

- [Specta](https://github.com/oscartbeaumont/specta) - Core type introspection library
- [Specta TypeScript](https://github.com/oscartbeaumont/specta/tree/main/specta-typescript) - TypeScript exporter
- [Specta Go](https://github.com/oscartbeaumont/specta/tree/main/specta-go) - Go exporter
