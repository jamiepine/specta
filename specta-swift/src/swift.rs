//! Swift language exporter configuration and main export functionality.

use std::{borrow::Cow, path::Path};

use specta::TypeCollection;

use crate::error::{Error, Result};
use crate::primitives::export_type;

/// Swift language exporter.
#[derive(Debug, Clone)]
pub struct Swift {
    /// Header comment for generated files.
    pub header: Cow<'static, str>,
    /// Indentation style for generated code.
    pub indent: IndentStyle,
    /// Naming convention for identifiers.
    pub naming: NamingConvention,
    /// Generic type style.
    pub generics: GenericStyle,
    /// Optional type style.
    pub optionals: OptionalStyle,
    /// Additional protocols to conform to.
    pub protocols: Vec<Cow<'static, str>>,
    /// Enable Serde validation.
    pub serde: bool,
}

/// Indentation style for generated Swift code.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum IndentStyle {
    /// Use spaces for indentation.
    Spaces(usize),
    /// Use tabs for indentation.
    Tabs,
}

impl Default for IndentStyle {
    fn default() -> Self {
        Self::Spaces(4)
    }
}

/// Naming convention for Swift identifiers.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum NamingConvention {
    /// PascalCase naming (default for Swift types).
    #[default]
    PascalCase,
    /// camelCase naming.
    CamelCase,
    /// snake_case naming.
    SnakeCase,
}

/// Generic type style for Swift.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum GenericStyle {
    /// Use protocol constraints: `<T: Codable>`.
    #[default]
    Protocol,
    /// Use where clauses: `<T> where T: Codable`.
    Typealias,
}

/// Optional type style for Swift.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OptionalStyle {
    /// Use question mark syntax: `String?`.
    #[default]
    QuestionMark,
    /// Use Optional type: `Optional<String>`.
    Optional,
}

impl Default for Swift {
    fn default() -> Self {
        Self {
            header: "// This file has been generated by Specta. DO NOT EDIT.".into(),
            indent: IndentStyle::default(),
            naming: NamingConvention::default(),
            generics: GenericStyle::default(),
            optionals: OptionalStyle::default(),
            protocols: vec![],
            serde: false,
        }
    }
}

impl Swift {
    /// Create a new Swift exporter with default configuration.
    pub fn new() -> Self {
        Self::default()
    }

    /// Set the header comment for generated files.
    pub fn header(mut self, header: impl Into<Cow<'static, str>>) -> Self {
        self.header = header.into();
        self
    }

    /// Set the indentation style.
    pub fn indent(mut self, style: IndentStyle) -> Self {
        self.indent = style;
        self
    }

    /// Set the naming convention.
    pub fn naming(mut self, convention: NamingConvention) -> Self {
        self.naming = convention;
        self
    }

    /// Set the generic type style.
    pub fn generics(mut self, style: GenericStyle) -> Self {
        self.generics = style;
        self
    }

    /// Set the optional type style.
    pub fn optionals(mut self, style: OptionalStyle) -> Self {
        self.optionals = style;
        self
    }

    /// Enable Serde validation.
    pub fn with_serde(mut self) -> Self {
        self.serde = true;
        self
    }

    /// Add a protocol that all types should conform to.
    pub fn add_protocol(mut self, protocol: impl Into<Cow<'static, str>>) -> Self {
        self.protocols.push(protocol.into());
        self
    }

    /// Export types to a Swift string.
    pub fn export(&self, types: &TypeCollection) -> Result<String> {
        if self.serde {
            specta_serde::validate(types)?;
        }

        let mut result = String::new();

        // Add header
        if !self.header.is_empty() {
            result.push_str(&self.header);
            result.push('\n');
        }

        // Add imports
        result.push_str("import Foundation\n");
        if self.serde {
            result.push_str("import Codable\n");
        }
        for protocol in &self.protocols {
            result.push_str(&format!("import {}\n", protocol));
        }
        result.push('\n');

        // Export types
        for ndt in types.into_sorted_iter() {
            result.push_str(&export_type(self, types, &ndt)?);
            result.push_str("\n\n");
        }

        Ok(result)
    }

    /// Export types to a file.
    pub fn export_to(&self, path: impl AsRef<Path>, types: &TypeCollection) -> Result<()> {
        let content = self.export(types)?;
        std::fs::write(path, content)?;
        Ok(())
    }
}

impl NamingConvention {
    /// Convert a string to the appropriate naming convention.
    pub fn convert(&self, name: &str) -> String {
        match self {
            Self::PascalCase => self.to_pascal_case(name),
            Self::CamelCase => self.to_camel_case(name),
            Self::SnakeCase => self.to_snake_case(name),
        }
    }

    /// Convert a string to camelCase (for field names).
    pub fn convert_to_camel_case(&self, name: &str) -> String {
        self.to_camel_case(name)
    }

    /// Convert a string to the appropriate naming convention for fields.
    pub fn convert_field(&self, name: &str) -> String {
        match self {
            Self::PascalCase => self.to_camel_case(name), // Fields should be camelCase even with PascalCase
            Self::CamelCase => self.to_camel_case(name),
            Self::SnakeCase => self.to_snake_case(name),
        }
    }

    /// Convert a string to the appropriate naming convention for enum cases.
    pub fn convert_enum_case(&self, name: &str) -> String {
        match self {
            Self::PascalCase => self.to_camel_case(name), // Enum cases should be camelCase
            Self::CamelCase => self.to_camel_case(name),
            Self::SnakeCase => self.to_snake_case(name),
        }
    }

    fn to_camel_case(&self, name: &str) -> String {
        // Convert snake_case to camelCase
        let parts: Vec<&str> = name.split('_').collect();
        if parts.is_empty() {
            return name.to_string();
        }

        let mut result = String::new();
        for (i, part) in parts.iter().enumerate() {
            if i == 0 {
                result.push_str(&part.to_lowercase());
            } else {
                let mut chars = part.chars();
                match chars.next() {
                    None => continue,
                    Some(first) => {
                        result.push(first.to_uppercase().next().unwrap_or(first));
                        for c in chars {
                            result.extend(c.to_lowercase());
                        }
                    }
                }
            }
        }
        result
    }

    fn to_pascal_case(&self, name: &str) -> String {
        // Convert snake_case to PascalCase
        name.split('_')
            .map(|part| {
                let mut chars = part.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => first.to_uppercase().chain(chars).collect(),
                }
            })
            .collect()
    }

    fn to_snake_case(&self, name: &str) -> String {
        // Convert camelCase/PascalCase to snake_case
        let mut result = String::new();
        let mut chars = name.chars().peekable();

        while let Some(c) = chars.next() {
            if c.is_uppercase() && !result.is_empty() {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap_or(c));
        }

        result
    }
}
